---
slug: "performance-optimization"
description: "パフォーマンス問題を計測→原因特定→最小最適化→再計測→回帰確認（verify-code）まで一気通貫で行い、改善を数値で証明する専門ワークフロー。"
trigger: "manual"
---

# ⚙️ performance-optimization — パフォーマンス最適化（専門ワークフロー）

このワークフローは、**「遅い」問題を属人化させずに収束**させるための型です。  
Convoy では、最適化は必ず **計測（Evidence）→改善→再計測→回帰確認**の順で行い、改善率を数値で示します。

---

## 定義（このワークフローの狙い）
- 体感や推測ではなく、**ベースライン計測**で現状を確定する
- ボトルネックを特定し、**最もインパクトの大きい最小変更**を優先する
- 変更の効果を **同一条件**で再計測し、改善を証明する
- 最適化が機能を壊していないことを **verify-code** で保証する

---

## SoT（Source of Truth）
- プロダクト要件/対象プラットフォーム: `assets/branding/<productId>/brief.md`
- 品質ゲート: `/verify-code`
- ルール（任意）: `@performance-guidelines` / `@type-safety` / `@security-mandates`
- 利用可能コマンド一覧: `.agent/INDEX.md`

---

## 入力（Inputs）
ユーザーから以下を受け取る（分かる範囲でOK）：

- 症状: 何が遅いか（画面/API/処理名）
- 再現条件: いつ遅いか（データ量、操作手順、端末、ネットワーク）
- 期待値: 許容できる速度（例: 300ms以内、初期表示2秒以内）
- 対象範囲: `UI` / `API` / `DB` / `バッチ` / `ビルド` など
- 既存計測: ログ、プロファイラ、スクショ、計測ツールの結果（あれば）

---

## 成果物（Outputs）
- 計測条件（ベースライン）と結果（Evidence）
- ボトルネック仮説と根拠
- 実施した最適化（変更点の要約）
- 再計測結果（Before/After、改善率）
- 回帰確認（verify-code結果）
- トレードオフ（あれば）と次のアクション

---

## 安全ガード（Convoy標準）
- 推測で最適化しない（計測なしの変更は禁止）
- 大規模リファクタは原則しない（必要なら提案→承認）
- 危険操作（依存更新、設定変更、push/リリース）は承認が必要
- “速くなるかも” ではなく **改善率** を報告する

---

# 手順

## Step 1: 事象の確定（再現性と影響範囲）
以下を整理する：

- 再現手順（最小）
- 影響範囲（ユーザー影響、頻度、対象機能）
- 成功条件（改善目標）

**出力（必須）**
- 「再現手順」「成功条件」を文面で確定

---

## Step 2: ベースライン計測（Before） // turbo
最適化前の **基準値** を計測する。  
計測は「同一条件」で再実行できるよう、条件を固定する。

### 計測項目（選択）
- 実行時間（p50/p95が望ましい）
- メモリ使用量（ピーク/平均）
- CPU（ピーク/平均）
- UIならフレーム落ち、LCP/TTI、初期描画時間
- DB/IOならクエリ回数、N+1の有無、転送量

**Evidence（必須）**
- 実行コマンド/手順
- 計測値（表形式が望ましい）
- 可能ならログ/スクショの場所

---

## Step 3: ボトルネック特定（仮説→検証）
以下の順で切り分ける（必要な範囲だけ）：

1. **アルゴリズム/計算量**: O(n²) の疑い、重いループ
2. **I/O**: DB/API呼び出し回数、待ち時間、N+1
3. **レンダリング**: 再レンダリング過多、巨大DOM/Widget、無駄な状態更新
4. **メモリ**: 大配列、キャッシュ肥大、リーク疑い
5. **並列性**: 逐次await、バッチ化不足

**出力（必須）**
- ボトルネックの候補（最大3つ）
- 各候補の根拠（ログ/プロファイル/計測）

---

## Step 4: 最適化戦略の提示（最小変更を優先）
最適化案を “インパクト × リスク” で優先順位づけして提示する。

### 例（戦略カテゴリ）
- アルゴリズム改善（計算量削減、早期return、不要処理削減）
- データ構造改善（Map/Set、インデックス、キャッシュ、遅延評価）
- I/O最適化（バッチ、並列、キャッシュ、クエリ統合）
- レンダリング最適化（メモ化、分割、仮想化、不要再描画抑制）
- メモリ最適化（ストリーミング、チャンク、寿命管理）

**承認ポイント（重要）**
- 仕様変更、UI挙動変更、依存追加、設定変更を含む場合は実装前に承認を取る

---

## Step 5: 実装（最適化を段階的に）
- 1つの最適化 = 1コミット（可能な範囲）
- 変更は最小限
- 計測のためだけのログ追加は、必要なら可（ただし後で除去/制御）

---

## Step 6: 再計測（After） // turbo
Step 2 と **同一条件** で再計測し、Before/After を比較する。

**必須**
- 改善率（%）を算出
- 改善していない場合は「何が原因か」を短く整理し、次手を提案

---

## Step 7: 回帰確認（品質ゲート） // turbo
最適化で機能が壊れていないことを確認する：

- 実行: `/verify-code`

> ここで FAIL なら、最適化は “未完了”。原因を整理し、必要なら `bug-fix` に移行する。

---

## Step 8: 結果報告（Convoy標準）
```markdown
## ⚙️ performance-optimization 結果

### 対象
- 症状: <何が遅いか>
- 再現手順: <最小手順>
- 成功条件: <目標>

### 計測（Evidence）
| Metric | Before | After | Δ | Improve |
|---|---:|---:|---:|---:|
| p50 latency | <ms> | <ms> | <ms> | <%%> |
| p95 latency | <ms> | <ms> | <ms> | <%%> |
| memory peak | <MB> | <MB> | <MB> | <%%> |

- 条件: <端末/データ量/URL/コマンド等>

### ボトルネック
- 主要原因: <要約>
- 根拠: <ログ/プロファイル/計測>

### 実施した最適化
1. <変更>（意図/リスク）
2. ...

### 回帰確認
- verify-code: PASS / FAIL
- 所見: <短く>

### トレードオフ
- <あれば>

### 次のアクション（任意）
- <追加の改善案、監視、性能テストの導入など>
```

---

## 付録: 典型的な次の一手（任意）
- 性能テストをCIに追加（しきい値を設定）
- 計測を継続（ログ/メトリクス/ダッシュボード）
- ホットパス周辺のユニットテスト増強（回帰防止）


